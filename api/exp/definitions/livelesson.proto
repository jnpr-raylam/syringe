syntax = "proto3";
package syringe.api.exp;

import "google/api/annotations.proto";
import "google/protobuf/empty.proto";

service LiveLessonsService {

  // Request a lab is created, or request the UUID of one that already exists for these parameters.
  rpc RequestLiveLesson(LessonParams) returns (LessonUUID) {
    option (google.api.http) = {
      post: "/exp/livelesson"
      body: "*"
    };
  }

  // SetLiveLesson updates certain parameters of an existing LiveLesson, such as setting the LessonStage
  rpc SetLiveLesson(LessonParams) returns (LessonUUID) {
    option (google.api.http) = {
      post: "/exp/livelesson/{lessonId}"
      body: "*"
    };
  }

  // Delete a running livelab
  rpc DeleteLiveLesson(LessonParams) returns (LiveLesson) {
    option (google.api.http) = {
      delete: "/exp/livelesson"
      body: "*"
    };
  }

  // Retrieve details about a lesson
  rpc GetLiveLesson(LessonUUID) returns (LiveLesson) {
    option (google.api.http) = {
      get: "/exp/livelesson/{id}"
    };
  }

  // Retrieve all livelessons
  rpc ListLiveLessons(google.protobuf.Empty) returns (LiveLessons) {
    option (google.api.http) = {
      get: "/exp/livelesson/all"
    };
  }

  // TODO(mierdin): Need to add instrumentation requests, so we can get visibility into the list of livelessons, labdefs, etc.



}

message LiveLessons {
  repeated LiveLessons livelessons = 1;
}

// A provisioned lab without the scheduler details. The server will translate from an underlying type
// (i.e. KubeLab) into this, so only the abstract, relevant details are presented.
message LiveLesson {
  string LessonUUID = 1;
  int32 LessonId = 2;
  repeated Endpoint Endpoints  = 3;
  int32 LessonStage = 4;
  string LabGuide = 5;
  bool Ready = 6;
}

message Endpoint {
  string Name  = 1;

  // This field helps the web client understand how to connect to this endpoint. Some might be done via SSH/Guacamole, others might be iframes, etc.
  enum EndpointType {
    UNKNOWN = 0;       // In proto3, zero value fields are indistinguishable from unset fields, by design. They are not sent on the wire either. So let's set this aside.
    DEVICE = 1;        // A network device. Expected to be reachable via SSH or API on the listed port
    NOTEBOOK = 2;      // Jupyter server
    BLACKBOX = 3;      // Some kind of entity that the user doesn't have access to (i.e. for troubleshooting)
    LINUX = 4;         // Linux container we want to provide access to for tools. Handled pretty much the same as DEVICE, as we SSH to this.
    // CONFIGURATOR = 5;  // Configurator container that's responsible for bootstrapping the lab devices
  }
  EndpointType Type = 2;

  // Port for normal operations. If type "device", used for SSH. If type "notebook", loads up in an iframe.
  int32 Port  = 3;

  // Extra port for API interactions.
  // Note that this mostly doesn't matter, as this is only in case we want to allow API interactions from outside
  // the cluster via NodePort. Most of the time we'll use the standard ports using in-cluster traffic.
  int32 Api_port  = 4;
}

message LessonParams {
  int32 lessonId = 1;
  string sessionId = 2;
  int32 lessonStage = 3;
}

message LessonUUID {
  string id = 1;
}


